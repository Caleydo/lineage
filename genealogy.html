<!--D3 IMPORT -->
<script src="https://d3js.org/d3.v4.js"></script>
<script src="utils.js"></script>
<script>
    /**
     * This example shows how to use the sigma.plugins.animate plugin. It
     * creates a random graph with two different views:
     *
     * The circular view displays the nodes on a circle, with each node
     * having a random color and a random size.
     *
     * The grid view displays every nodes with the same size, and on a grid.
     *
     * Every two seconds, the graph will be animated from a view to the other
     * one, in a one second animation.
     */
    var g = {
                nodes: [],
                edges: []
            },
            uniqueID=[];
    names = ['A','B','C','D','E','F','G','H','I','J','K'];

    d3.csv("data/genealogy.csv", function (error, data) {

        data.forEach(function (d, i) {
            if (i <100 && +d['egoUPDBID']>0 & +d['bdate']>0) {

                d.id = +d['egoUPDBID']
                d.label = names[i]
//                d.label = 'TEST'
                d.ma = +d['maUPDBID']
                d.pa = +d['paUPDBID']
                d.spouse = undefined
                d.children =0;
                d.x = 0
                d.y = undefined
                d.generation = undefined;
                d.size = d['deceased'] == 1 ? 2 : 2
                d.color = d['sex'] == 'M' ? '#263d60' : '#a91d4e'

                //Skip duplicate rows
                if (uniqueID.indexOf(d.id) == -1) {
                    g.nodes.push(d);
                    uniqueID.push(d.id);
                }
            }

        });

        g.nodes.forEach(function(d,i){
            if (uniqueID.indexOf(d['ma']) != -1){
                g.edges.push({
                    id: 'e1' + i,
                    source: g.nodes[uniqueID.indexOf(d['id'])],
                    target: g.nodes[uniqueID.indexOf(d['ma'])]
                });
            }
            if (uniqueID.indexOf(d['pa']) != -1) {
                g.edges.push({
                    id: 'e2' + i,
                    source: g.nodes[uniqueID.indexOf(d['id'])],
                    target: g.nodes[uniqueID.indexOf(d['pa'])]
                })
            }

        });

        //sort by year of birth
        g.nodes.sort(function(a, b) {
            return parseFloat(b['bdate']) - parseFloat(a['bdate']);
        });

        uniqueID=[];
        g.nodes.forEach(function(d){
            uniqueID.push(d.id);
        });

        //Store spouse and children in each node;
        g.nodes.forEach(function(node){
            var maID = uniqueID.indexOf(node['ma']);
            var paID = uniqueID.indexOf(node['pa']);

            if (maID >-1 && paID >-1){
                g.nodes[maID].spouse = node['pa'];
                g.nodes[paID].spouse = node['ma'];
                g.nodes[maID].children = g.nodes[maID].children+1;
                g.nodes[paID].children = g.nodes[paID].children+1
            }
        })

        g.nodes.forEach(function(node,ind){assignGeneration(node,ind)});

        //sort by generation
        g.nodes.sort(function(a, b) {
            return parseFloat(a['generation']) - parseFloat(b['generation']);
        });

        uniqueID=[];
        g.nodes.forEach(function(d){
            uniqueID.push(d.id);
        });

        g.nodes.forEach(function(node){node.x = node.generation});

//        g.nodes.forEach(function(node,i){node.y = i});

        g.nodes[0].y = 1;
        g.nodes.forEach(function(node){assignOrder(node)});

        relationshipNodes=[];
        relationshipEdges=[];

        //Create relationship nodes
        g.nodes.forEach(function(node){
            var maID = uniqueID.indexOf(node['ma']);
            var paID = uniqueID.indexOf(node['pa']);

            if (maID >-1 && paID >-1){
                rnode={
                    'x':g.nodes[maID].x,
                    'y':(g.nodes[maID].y + g.nodes[paID].y)/2,
                    'y1':g.nodes[maID].y,
                    'y2':g.nodes[paID].y,
                }
                relationshipNodes.push(rnode);
                relationshipEdges.push({
                    source: rnode,
                    target: node
                })
            }
        })

//      Render Genealogy to the Screen
        minLevel = d3.min(g.nodes,function(d){return d.x});
        maxLevel = d3.max(g.nodes,function(d){return d.x});

        glyphSize = 8;
        margin = {top: 20, right: 120, bottom: 20, left: 20},
                width = (maxLevel - minLevel)*200,
                height = (glyphSize+3)  * g.nodes.length * 2;

         x = d3.scaleLinear().range([0, width]).domain([minLevel, maxLevel]);
         y = d3.scaleLinear().range([0, height]).domain([0, g.nodes.length]);
         connectorScale = d3.scaleLinear().range([.75 , .25]).domain([2, g.nodes.length])

        var svg = d3.select("body").append("svg")
                .attr("width", width + margin.right + margin.left)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var edges = svg.selectAll("g.edges")
                .data(relationshipEdges)
                .enter().append("path")
                .attr("class", "edges")
                .style("stroke", '#000')
                .style("fill",'none')
                .attr("d",elbow)


        var edges = svg.selectAll("g.parentEdges")
                .data(relationshipNodes)
                .enter().append("path")
                .attr("class", "parentEdges")
                .style("stroke", '#000')
                .style("stroke-width",2)
                .style("fill",'none')
                .attr("d", parentEdge);

        var fnodes = svg.selectAll("g.node .female")
                .data(g.nodes.filter(function(d){return d['sex'] == 'F'}))
                .enter()
                .append("g")
                .attr("class", "node")
                .attr("transform", function(d) { return "translate(" + xPOS(d) + "," + yPOS(d)+ ")"; })
                .append("circle")
                .attr("r", glyphSize)
//                .style("fill", function(d) { return d.color})
                .style("fill", 'white')
                .style('stroke','#000')

        var mnodes = svg.selectAll("g.node .male")
                .data(g.nodes.filter(function(d){return d['sex'] == 'M'}))
                .enter()
                .append("g")
                .attr("class", "node")
                .attr("transform", function(d) { return "translate(" + xPOS(d) + "," + yPOS(d)+ ")"; })
                .append("rect")
                .attr("width", glyphSize*2)
                .attr("height", glyphSize*2)
                .style("fill", 'white')
                .style('stroke','#000')
//
//        svg.selectAll('g.node')
//                .append('text')
//                .text(function(d){return d.label})
//                .attr('fontsize',12)
//                .attr('dx',-glyphSize)
//                .attr('dy',glyphSize)

    })

</script>
