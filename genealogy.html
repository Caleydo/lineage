<!--D3 IMPORT -->
<script src="https://d3js.org/d3.v4.js"></script>
<script>
/**
 * This example shows how to use the sigma.plugins.animate plugin. It
 * creates a random graph with two different views:
 *
 * The circular view displays the nodes on a circle, with each node
 * having a random color and a random size.
 *
 * The grid view displays every nodes with the same size, and on a grid.
 *
 * Every two seconds, the graph will be animated from a view to the other
 * one, in a one second animation.
 */
var g = {
      nodes: [],
      edges: []
    },
  uniqueID=[],
        nodeSize = 10;

d3.csv("data/genealogyTest.csv", function (error, data) {

  data.forEach(function (d, i) {
//    console.log(i)
    if (i < 30 && +d['egoUPDBID']>0 & +d['bdate']>0) {

        d.id = +d['egoUPDBID']
        d.label = d['egoUPDBID']
        d.ma = +d['maUPDBID']
        d.pa = +d['paUPDBID']
        d.x = i
        d.y = 0
        d.size = d['deceased'] == 1 ? 4 : 4
        d.color = d['sex'] == 'M' ? '#263d60' : '#a91d4e'


      if (uniqueID.indexOf(d.id) == -1) {
        g.nodes.push(d);
        uniqueID.push(d.id);
      }
    }

  });

  g.nodes.forEach(function(d,i){

      if (uniqueID.indexOf(d['ma']) != -1){
        g.edges.push({
          id: 'e1' + i,
            source: g.nodes[uniqueID.indexOf(d['id'])],
            target: g.nodes[uniqueID.indexOf(d['ma'])]
        });
      }

      if (uniqueID.indexOf(d['pa']) != -1) {
        g.edges.push({
          id: 'e2' + i,
          source: g.nodes[uniqueID.indexOf(d['id'])],
          target: g.nodes[uniqueID.indexOf(d['pa'])]
        })
      }

  });

    g.nodes.sort(function(a, b) {
        return parseFloat(b['bdate']) - parseFloat(a['bdate']);
    });

    uniqueID=[];
    g.nodes.forEach(function(d){
        uniqueID.push(d.id);
    })

    //Youngest Node gets level 1
    g.nodes[0].y = 1;

    count = 0;
    remainingNodes = g.nodes;
    while (remainingNodes.length>0){
        count = count +1;
        console.log('iterating through' , remainingNodes.length, 'nodes');
        tocheck = [];
        remainingNodes.forEach(function (d) {

//            console.log('looking at node', d.id, ' with a level of ', d.y);
            //First pass only consider nodes that have a level defined and define the parent levels from that
            if (d.y > 0) {
                if (uniqueID.indexOf(d['ma']) != -1 && g.nodes[uniqueID.indexOf(d['ma'])].y == 0) {
                    console.log('assigning level', d.y + 1, 'to mom (node', g.nodes[uniqueID.indexOf(d['ma'])].id, ')');
                    g.nodes[uniqueID.indexOf(d['ma'])].y = d.y + 1;
                }

                if (uniqueID.indexOf(d['pa']) != -1 && g.nodes[uniqueID.indexOf(d['pa'])].y == 0) {
                    console.log('assigning level', d.y + 1, 'to dad (node', g.nodes[uniqueID.indexOf(d['pa'])].id, ')');
                    g.nodes[uniqueID.indexOf(d['pa'])].y = d.y + 1;
                }
            }
            //See if you can derive level from parent's level
            if (d.y == 0) {
                if (uniqueID.indexOf(d['ma']) != -1 && g.nodes[uniqueID.indexOf(d['ma'])].y != 0) {
                    console.log('assigning level', g.nodes[uniqueID.indexOf(d['ma'])].y - 1, 'to node' , d.id);
                    d.y = g.nodes[uniqueID.indexOf(d['ma'])].y - 1;
                }

                else if (uniqueID.indexOf(d['ma']) != -1 && g.nodes[uniqueID.indexOf(d['ma'])].y != 0) {
                    console.log('assigning level', g.nodes[uniqueID.indexOf(d['pa'])].y - 1, 'to node', d.id);
                    d.y = g.nodes[uniqueID.indexOf(d['pa'])].y - 1;
                }
                else{
                    tocheck.push(d);
                }

            }
        })
        remainingNodes = tocheck;

        if (count >100){
            console.log('break at ' , count)
            break;
        }
    }

    g.nodes.forEach(function(d){d.y = -d.y});

    minLevel = d3.min(g.nodes,function(d){return d.y});
    maxLevel = d3.max(g.nodes,function(d){return d.y});
    console.log( 'minLevel is ', minLevel , '  max level is ',  maxLevel)


    var margin = {top: 20, right: 120, bottom: 20, left: 120},
            width = 960 - margin.right - margin.left,
            height = 500 - margin.top - margin.bottom;

    var x = d3.scaleLinear().range([margin.left , width]).domain([0,g.nodes.length]);
    var y = d3.scaleLinear().range([margin.top , height]).domain([minLevel, maxLevel]);

    var svg = d3.select("body").append("svg")
            .attr("width", width + margin.right + margin.left)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var link = svg.selectAll("g.link")
            .data(g.edges)
            .enter().append("path")
            .attr("class", "link")
            .style("stroke", '#000')
            .style("fill",'none')
            .attr("d", elbow);

    var node = svg.selectAll("g.node")
            .data(g.nodes)
            .enter()
            .append("g")
            .attr("class", "node")
            .attr("transform", function(d) { return "translate(" + x(d.x) + "," + y(d.y)+ ")"; })
            .append("circle")
            .attr("r", nodeSize)
            .style("fill", function(d) { return d.color})
            .append("text")
            .attr("x", 13)
            .attr("dy", ".35em")
            .attr("text-anchor", "end")
            .text(function(d) { return d.id; })
            .style("fill-opacity", 1e-6);

    function elbow(d, i) {
        var diff = d.source.y - d.target.y;
        //0.40 defines the point from where you need the line to break out change is as per your choice.
        var ny = d.target.y + diff * 0.40;

        linedata = [{
            x: d.target.x,
            y: d.target.y
        }, {
            x: d.target.x,
            y: ny
        }, {
            x: d.source.x,
            y: d.source.y
        }]

        var fun = d3.line().x(function (d) {
            return x(d.x);
        }).y(function (d) {
            return y(d.y);
        })
        return fun(linedata);
    }
 console.log('done')


})

</script>
