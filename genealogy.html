<!--D3 IMPORT -->
<script src="https://d3js.org/d3.v4.js"></script>
<script>
    /**
     * This example shows how to use the sigma.plugins.animate plugin. It
     * creates a random graph with two different views:
     *
     * The circular view displays the nodes on a circle, with each node
     * having a random color and a random size.
     *
     * The grid view displays every nodes with the same size, and on a grid.
     *
     * Every two seconds, the graph will be animated from a view to the other
     * one, in a one second animation.
     */
    var g = {
                nodes: [],
                edges: []
            },
            uniqueID=[],
            nodeSize = 10;

    names = ['A','B','C','D','E','F','G','H','I','J','K'];
    d3.csv("data/genealogy.csv", function (error, data) {

        data.forEach(function (d, i) {
            if (i < 200 && +d['egoUPDBID']>0 & +d['bdate']>0) {

                d.id = +d['egoUPDBID']
//                d.label = names[i]
                d.label = 'TEST'
                d.ma = +d['maUPDBID']
                d.pa = +d['paUPDBID']
                d.x = i
                d.y = 0
                d.generation = undefined;
                d.size = d['deceased'] == 1 ? 4 : 4
                d.color = d['sex'] == 'M' ? '#263d60' : '#a91d4e'


                if (uniqueID.indexOf(d.id) == -1) {
                    g.nodes.push(d);
                    uniqueID.push(d.id);
                }
            }

        });

        g.nodes.forEach(function(d,i){

            if (uniqueID.indexOf(d['ma']) != -1){
                g.edges.push({
                    id: 'e1' + i,
                    source: g.nodes[uniqueID.indexOf(d['id'])],
                    target: g.nodes[uniqueID.indexOf(d['ma'])]
                });
            }

            if (uniqueID.indexOf(d['pa']) != -1) {
                g.edges.push({
                    id: 'e2' + i,
                    source: g.nodes[uniqueID.indexOf(d['id'])],
                    target: g.nodes[uniqueID.indexOf(d['pa'])]
                })
            }

        });

        g.nodes.sort(function(a, b) {
            return parseFloat(b['bdate']) - parseFloat(a['bdate']);
        });

        uniqueID=[];
        g.nodes.forEach(function(d){
            uniqueID.push(d.id);
        })

        //Youngest Node gets level 1
        g.nodes[0].y = 1;

        g.nodes.forEach(function(node,ind){assignGeneration(node,ind)});

        function assignGeneration(node,ind){
            if (node.generation == undefined) {
//                console.log('assigning generation to node ',  node.label , '***********************')
                node.generation = getParentGeneration(ind);
                if (node.generation == undefined)
                    node.generation = 1;

//                console.log('assigning node generation ', node.generation, ' to node ', node.label)
                setParentGeneration(ind, node.generation)
            }
        }

        function setParentGeneration(nodeID,generation){
            var node = g.nodes[nodeID]

            var maID = uniqueID.indexOf(node['ma']);
            var paID = uniqueID.indexOf(node['pa']);

            //Mother exists in array of nodes and does not have a generation assigned
            if (maID > -1 && g.nodes[maID].generation == undefined) {
                g.nodes[maID].generation = generation + 1;
//                console.log('assigning mom parent generation ', generation +1,  ' to node ', g.nodes[maID].label)
                setParentGeneration(maID,generation+1)
            }

            //Father exists in array of nodes and does not have a generation assigned
            if (paID > -1 && g.nodes[paID].generation == undefined) {
                g.nodes[paID].generation = generation + 1;
//                console.log('assigning dad parent generation ', generation +1,  ' to node ', g.nodes[paID].label)
                setParentGeneration(paID,generation+1)
            }

        }
        function getParentGeneration(nodeID){

            var node = g.nodes[nodeID]
            var maID = uniqueID.indexOf(node['ma']);
            var paID = uniqueID.indexOf(node['pa']);

//            console.log('nodeID is ', nodeID, 'node is ', node.label, 'maID is', maID , ' paID is ', paID)


            if (maID >-1) { //Mother exists in array of nodes
//                console.log('maNode is', g.nodes[maID].label);
                maGeneration = g.nodes[maID].generation
                if (maGeneration == undefined) {
//                    console.log('calling getParentGeneration on mom', g.nodes[maID].label)
                    maGeneration = getParentGeneration(maID)
//                    console.log('returned getParentGeneration on mom', g.nodes[maID] , 'value:', maGeneration)

                }
            }
            else {
                maGeneration = false;
            }
            if (paID >-1) { //Father exists in array of nodes
                paGeneration = g.nodes[paID].generation
                if (paGeneration == undefined) {
//                    console.log('calling getParentGeneration on dad', g.nodes[paID].label)
                    paGeneration = getParentGeneration(paID) //continue searching up the tree
//                    console.log('returned getParentGeneration on dad', g.nodes[paID].label , 'value:', paGeneration)

                }
            }
            else {
                paGeneration = false;
            }

//            console.log('determining join parent generation:', maGeneration, paGeneration)
            if (maGeneration && paGeneration)
                return (maGeneration + paGeneration) / 2 -1
            else if (maGeneration || paGeneration)
                return (maGeneration || paGeneration) - 1
            else
                return undefined
        }

        g.nodes.forEach(function(d){d.y = -d.generation});

        minLevel = d3.min(g.nodes,function(d){return d.y});
        maxLevel = d3.max(g.nodes,function(d){return d.y});

        console.log( 'minLevel is ', minLevel , '  max level is ',  maxLevel)


        var margin = {top: 20, right: 120, bottom: 20, left: 120},
                width = 960 - margin.right - margin.left,
                height = 500 - margin.top - margin.bottom;

        var x = d3.scaleLinear().range([margin.left , width]).domain([0,g.nodes.length]);
        var y = d3.scaleLinear().range([margin.top , height]).domain([minLevel, maxLevel]);

        var svg = d3.select("body").append("svg")
                .attr("width", width + margin.right + margin.left)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        var link = svg.selectAll("g.link")
                .data(g.edges)
                .enter().append("path")
                .attr("class", "link")
                .style("stroke", '#000')
                .style("fill",'none')
                .attr("d", elbow);

        var node = svg.selectAll("g.node")
                .data(g.nodes)
                .enter()
                .append("g")
                .attr("class", "node")
                .attr("transform", function(d) { return "translate(" + x(d.x) + "," + y(d.y)+ ")"; })
                .append("circle")
                .attr("r", nodeSize)
                .style("fill", function(d) { return d.color})
                .append("text")
                .attr("x", 13)
                .attr("dy", ".35em")
                .attr("text-anchor", "end")
                .text(function(d) { return d.id; })
                .style("fill-opacity", 1e-6);

        function elbow(d, i) {
            var diff = d.source.y - d.target.y;
            //0.40 defines the point from where you need the line to break out change is as per your choice.
            var ny = d.target.y + diff * 0.40;

            linedata = [{
                x: d.target.x,
                y: d.target.y
            }, {
                x: d.target.x,
                y: ny
            }, {
                x: d.source.x,
                y: d.source.y
            }]

            var fun = d3.line().x(function (d) {
                return x(d.x);
            }).y(function (d) {
                return y(d.y);
            })
            return fun(linedata);
        }
        console.log('done')


    })

</script>
